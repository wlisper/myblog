<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://blogawesome.com/' rel='self' type='application/rss+xml'/>
<title>
Buddha says: Let there be Guns
</title>
<link>
http://blogawesome.com/
</link>
<description>
my personal blog
</description>
<lastBuildDate>
Thu, 09 Aug 2018 21:35:52 +0800
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://blogawesome.com/blog/posts-output/2017-12-5-php_has_a_pipe/
</guid>
<link>
http://blogawesome.com/blog/posts-output/2017-12-5-php_has_a_pipe/
</link>
<title>
Php Has a Pipe
</title>
<description>
&lt;p&gt;&lt;img src=&quot;https://github.com/wlisper/myblog/blob/master/resources/templates/img/php-pipe.png?raw=true&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;PHP 是一根管子，你通常会把它的一端接到汽车的排气管，另一端插进车窗里，然后你坐进车里，开动引擎。&lt;/p&gt;&lt;p&gt;这是以前在网上看到的一则比喻，当时不懂其意；最近在工作中需要用到php，也踩了一些坑，才知道管子的比喻实在生动。&lt;/p&gt;&lt;p&gt;才开始接触php，你会发觉php的词法环境是有悖于大多数程序语言的设计的，一些你认为应该发生的，它不会让你如愿；一些你不希望发生的，它会悄悄的帮你做了。&lt;/p&gt;&lt;p&gt;比如下面的代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$env  = 'linux';
function fun1&amp;#40;&amp;#41; {
    if &amp;#40;$env == 'linux'&amp;#41; {
        do&amp;#95;something&amp;#40;&amp;#41;;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可能以为在env为linux的情况下，会做些事情。然而php并不会帮你做的，在php看来env不是一个全局变量，php有它的解决方案，你可以在函数中申明env为global的，就像下面这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$env = 'linux';
function fun2&amp;#40;&amp;#41; {
    global $env;    //  方便吧？
    if &amp;#40;$env == 'linux'&amp;#41; {
        do&amp;#95;something&amp;#40;&amp;#41;;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有时你不希望做的一些事，php会帮你做的。例如下面的代码:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;function fun3&amp;#40;&amp;#41; {

    $env = 'windows';   // 我的系统类型
    $allenv = array&amp;#40;
        'linux', 'windows', 'mac'
    &amp;#41;;
    foreach &amp;#40;$allenv as $env&amp;#41; {
        do&amp;#95;system&amp;#95;specific&amp;#40;$env&amp;#41;;   // 根据不同的系统，做一些特定的工作
    }

    do&amp;#95;my&amp;#95;system&amp;#95;work&amp;#40;$env&amp;#41;;   // 开始做自己系统相关的工作。
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可能以为在做完各种系统相关的工作后，还可以回来做自己系统相关的工作；然而你自己的系统已经变为mac了，后面的工作就全错了。发生这个的原因是php的foreach在迭代中修改了env的值，而且是 '外层’的env, 这就好像内层产生了废气, php不帮你回收清理, 反而将这些废气排到外面, 污染了外层环境, 增加出现bug的可能&lt;/p&gt;
</description>
<pubDate>
Tue, 05 Dec 2017 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/blog/posts-output/2017-12-5-lispy_syntactic_sugar/
</guid>
<link>
http://blogawesome.com/blog/posts-output/2017-12-5-lispy_syntactic_sugar/
</link>
<title>
lispy语法糖
</title>
<description>
&lt;p&gt;&lt;div id=&quot;table-of-contents&quot;&gt; &lt;h2&gt;Table of Contents&lt;/h2&gt; &lt;div id=&quot;text-table-of-contents&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#org258c079&quot;&gt;1. lispy语法糖&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#org747c3bc&quot;&gt;1.1. c风格for循环&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#orgc6362d0&quot;&gt;1.2. c风格while循环&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#org87c8956&quot;&gt;1.3. php风格foreach&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#org6bb79b5&quot;&gt;1.4. php数组语法糖[]&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#orgfe963ea&quot;&gt;1.5. 字面hash&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#orgab2fd74&quot;&gt;1.6. @型注释&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/p&gt;&lt;p&gt;&lt;a id=&quot;org258c079&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h1 id=&quot;lispy语法糖&quot;&gt;lispy语法糖&lt;/h1&gt;&lt;p&gt;语法糖虽甜，吃多了可会长蛀牙，里面还有很多bug哦。&lt;/p&gt;&lt;p&gt;&lt;a id=&quot;org747c3bc&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;c风格for循环&quot;&gt;c风格for循环&lt;/h2&gt;&lt;p&gt;lisp实现如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defmacro for &amp;#40;&amp;#40;init cond step&amp;#41; &amp;amp;body body&amp;#41;
  &amp;#40;rutils:with-gensyms &amp;#40;goto-tag exit-tag&amp;#41;
    `&amp;#40;let&amp;#42; ,init
       &amp;#40;tagbody
          ,goto-tag
           &amp;#40;labels &amp;#40;&amp;#40;my-continue &amp;#40;&amp;#41;
                      ,step &amp;#40;go ,goto-tag&amp;#41;&amp;#41;
                    &amp;#40;my-break &amp;#40;&amp;#41; &amp;#40;go ,exit-tag&amp;#41;&amp;#41;&amp;#41;
             &amp;#40;loop
                &amp;#40;unless ,cond &amp;#40;return&amp;#41;&amp;#41;
                ,@body
                ,step&amp;#41;&amp;#41;
          ,exit-tag&amp;#41;&amp;#41;&amp;#41;&amp;#41;

;; test
&amp;#40;for &amp;#40;&amp;#40;&amp;#40;i 0&amp;#41;&amp;#41; &amp;#40;&amp;lt; i 10&amp;#41; &amp;#40;incf i&amp;#41;&amp;#41;
    &amp;#40;if &amp;#40;= i 6&amp;#41; &amp;#40;my-break&amp;#41;&amp;#41;
    &amp;#40;if &amp;#40;evenp i&amp;#41; &amp;#40;my-continue&amp;#41;&amp;#41;
    &amp;#40;format t &amp;quot;&amp;#126;A&amp;#126;%&amp;quot; i&amp;#41;&amp;#41;
;; output
;1
;3
;5&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a id=&quot;orgc6362d0&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;c风格while循环&quot;&gt;c风格while循环&lt;/h2&gt;&lt;p&gt;lisp实现如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defmacro while &amp;#40;test &amp;amp;body body&amp;#41;
  `&amp;#40;for &amp;#40;&amp;#40;&amp;#41; ,test nil&amp;#41;
     ,@body&amp;#41;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a id=&quot;org87c8956&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;php风格foreach&quot;&gt;php风格foreach&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defmacro foreach &amp;#40;&amp;#40;var seq&amp;#41; &amp;amp;body body&amp;#41;
  &amp;#40;rutils:with-gensyms &amp;#40;seq-sym&amp;#41;
    `&amp;#40;let &amp;#40;&amp;#40;,seq-sym ,seq&amp;#41;&amp;#41;
       &amp;#40;if &amp;#40;listp ,seq-sym&amp;#41;
           &amp;#40;loop for ,var in ,seq-sym
              do &amp;#40;progn ,@body&amp;#41;&amp;#41;
           &amp;#40;loop for ,var across ,seq-sym
                do &amp;#40;progn ,@body&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

;; 作用于数组
&amp;#40;foreach &amp;#40;var #&amp;#40;1 2 3 4&amp;#41;&amp;#41;
  &amp;#40;format t &amp;quot;&amp;#126;A&amp;#126;%&amp;quot; var&amp;#41;&amp;#41;
;; 作用于链表
&amp;#40;foreach &amp;#40;var '&amp;#40;1 2 3 4&amp;#41;&amp;#41;
  &amp;#40;format t &amp;quot;&amp;#126;A&amp;#126;%&amp;quot; var&amp;#41;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a id=&quot;org6bb79b5&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;php数组语法糖[]&quot;&gt;php数组语法糖[]&lt;/h2&gt;&lt;p&gt;php可以这样构造数组：[1, 2, 3]。&lt;/p&gt;&lt;p&gt;lisp实现如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;set-macro-character #\&amp;#93; &amp;#40;get-macro-character #\&amp;#41;&amp;#41;&amp;#41;
&amp;#40;set-macro-character #\&amp;#91; &amp;#40;lambda &amp;#40;stream char&amp;#41;
                           &amp;#40;declare &amp;#40;ignore char&amp;#41;&amp;#41;
                           &amp;#40;let&amp;#42; &amp;#40;&amp;#40;lst &amp;#40;read-delimited-list #\&amp;#93; stream&amp;#41;&amp;#41;
                                  &amp;#40;res &amp;#40;make-array &amp;#40;length lst&amp;#41;&amp;#41;&amp;#41;&amp;#41;
                             &amp;#40;dotimes &amp;#40;i &amp;#40;length lst&amp;#41;&amp;#41;
                               &amp;#40;setf &amp;#40;aref res i&amp;#41; &amp;#40;elt lst i&amp;#41;&amp;#41;&amp;#41;
                             res&amp;#41;&amp;#41;&amp;#41;

;; 测试
;  输入:&amp;#91;1 2 3&amp;#93;   返回数组：#&amp;#40;1 2 3&amp;#41; 
;  输入:&amp;#91;&amp;quot;hello&amp;quot; 3 &amp;#91;1 2 3&amp;#93;&amp;#93;  返回嵌套数组:#&amp;#40;&amp;quot;hello&amp;quot; 3 #&amp;#40;1 2 3&amp;#41;&amp;#41;。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a id=&quot;orgfe963ea&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;字面hash&quot;&gt;字面hash&lt;/h2&gt;&lt;p&gt;很多语言都支持字面hash表,语法如下: {&quot;key1&quot; : value1, &quot;key2&quot; : value2};&lt;/p&gt;&lt;p&gt;lisp实现如下:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;set-macro-character #\} &amp;#40;get-macro-character #\&amp;#41;&amp;#41;&amp;#41;
&amp;#40;set-macro-character #\{ &amp;#40;lambda &amp;#40;stream char&amp;#41;
                           &amp;#40;declare &amp;#40;ignore char&amp;#41;&amp;#41;
                           &amp;#40;let&amp;#42; &amp;#40;&amp;#40;res &amp;#40;make-hash-table&amp;#41;&amp;#41;
                                  &amp;#40;lst &amp;#40;read-delimited-list #\} stream&amp;#41;&amp;#41;&amp;#41;
                             &amp;#40;dolist &amp;#40;pair lst&amp;#41;
                               &amp;#40;setf &amp;#40;gethash &amp;#40;car pair&amp;#41; res&amp;#41;
                                     &amp;#40;cdr pair&amp;#41;&amp;#41;&amp;#41;
                             res&amp;#41;&amp;#41;&amp;#41;

;; 测试
; 输入{&amp;#40;1 . 2&amp;#41; &amp;#40;3 . 4&amp;#41; &amp;#40;5 . 6&amp;#41;}
; 返回哈希表&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a id=&quot;orgab2fd74&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;@型注释&quot;&gt;@型注释&lt;/h2&gt;&lt;p&gt;例如：注册一个web控制器。 @controller public static void index() {&lt;pre&gt;&lt;code&gt;// &lt;/code&gt;&lt;/pre&gt;}&lt;/p&gt;&lt;p&gt;声明函数为内联。 @inline int fact(int n);&lt;/p&gt;&lt;p&gt;lisp实现如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;set-macro-character #\@ &amp;#40;lambda &amp;#40;stream char&amp;#41;
                           &amp;#40;declare &amp;#40;ignore char&amp;#41;&amp;#41;
                           &amp;#40;let &amp;#40;&amp;#40;sym &amp;#40;read stream&amp;#41;&amp;#41;
                                 &amp;#40;forms &amp;#40;read stream&amp;#41;&amp;#41;&amp;#41;
                             &amp;#40;cond &amp;#40;&amp;#40;eq sym 'controller&amp;#41;
                                    &amp;#40;progn 
                                       &amp;#40;format t &amp;quot;register controller: &amp;#126;A&amp;#126;%&amp;quot; &amp;#40;second forms&amp;#41;&amp;#41;
                                       ;; you can do more controller register work here
                                        forms&amp;#41;&amp;#41;
                                   &amp;#40;&amp;#40;eq sym 'inline&amp;#41;
                                    &amp;#40;progn &amp;#40;format t &amp;quot;declaring inline: &amp;#126;A&amp;#126;%&amp;quot; &amp;#40;second forms&amp;#41;&amp;#41;&amp;#41;
                                    `&amp;#40;,&amp;#40;first forms&amp;#41; ,&amp;#40;second forms&amp;#41; ,&amp;#40;third forms&amp;#41;
                                       &amp;#40;declare &amp;#40;inline ,&amp;#40;second forms&amp;#41;&amp;#41;&amp;#41;
                                       ,@&amp;#40;cdddr forms&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

;;; test
;; 控制器注释
@controller
&amp;#40;defun index &amp;#40;&amp;#41;
  &amp;#40;format t &amp;quot;this is my home page&amp;#126;%&amp;quot;&amp;#41;&amp;#41;

;; 内联注释
@inline
&amp;#40;defun square &amp;#40;n&amp;#41;
  &amp;#40;&amp;#42; n n&amp;#41;&amp;#41;&lt;/code&gt;&lt;/pre&gt;
</description>
<pubDate>
Tue, 05 Dec 2017 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/blog/posts-output/2017-12-2-topologic_sorting/
</guid>
<link>
http://blogawesome.com/blog/posts-output/2017-12-2-topologic_sorting/
</link>
<title>
拓扑排序
</title>
<description>
&lt;p&gt;&lt;div id=&quot;table-of-contents&quot;&gt; &lt;h2&gt;Table of Contents&lt;/h2&gt; &lt;div id=&quot;text-table-of-contents&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#org010e50b&quot;&gt;1. 拓扑排序&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#org805f137&quot;&gt;1.1. 拓扑排序算法一：&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#org058f8f1&quot;&gt;1.2. 拓扑排序算法二&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/p&gt;&lt;p&gt;&lt;a id=&quot;org010e50b&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h1 id=&quot;拓扑排序&quot;&gt;拓扑排序&lt;/h1&gt;&lt;p&gt;有向无环图(AOV)的拓扑排序，是将图中的顶点排序成一个全序序列，使得对于图中的任意一条有向边(v, u)，满足在拓扑中v出现在u前面。&lt;/p&gt;&lt;p&gt;拓扑排序通常用于大工程中子工程执行顺序的确定，一个大工程通常可以拆分成多个子工程，有些子工程又必须在子工程之前执行，这是就可以使用拓扑排序，对所有子工程进行排序。&lt;/p&gt;&lt;p&gt;&lt;a id=&quot;org805f137&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;拓扑排序算法一：&quot;&gt;拓扑排序算法一：&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;选择一个入度为0的顶点并输出。&lt;/li&gt;&lt;li&gt;从图中删除此定点和所有出边。&lt;/li&gt;&lt;li&gt;重复1，2步。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;循环结束后如果输出的顶点小于图中的顶点，则说明图中有回路。&lt;/p&gt;&lt;p&gt;common lisp实现如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defstruct vertex
  index  ;; vertex index
  in  ;; in edge
  out ;; out edge
  &amp;#41;

&amp;#40;defparameter &amp;#42;graph&amp;#42; &amp;#40;make-array 6 :element-type 'vertex&amp;#41;&amp;#41; ;; vertex array
&amp;#40;defun add-vertex &amp;#40;index in out&amp;#41;
  &amp;#40;setf &amp;#40;aref &amp;#42;graph&amp;#42; index&amp;#41;
        &amp;#40;make-vertex :index index
                     :in in
                     :out out&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defun topologic-sort &amp;#40;&amp;amp;optional &amp;#40;graph &amp;#42;graph&amp;#42;&amp;#41;&amp;#41;
  &amp;#40;dotimes &amp;#40;i &amp;#40;length graph&amp;#41;&amp;#41;
    &amp;#40;if &amp;#40;null &amp;#40;aref graph i&amp;#41;&amp;#41; nil
        &amp;#40;if &amp;#40;null &amp;#40;vertex-in &amp;#40;aref graph i&amp;#41;&amp;#41;&amp;#41;
            &amp;#40;progn &amp;#40;format t &amp;quot;&amp;#126;A&amp;#126;%&amp;quot; &amp;#40;vertex-index &amp;#40;aref graph i&amp;#41;&amp;#41;&amp;#41;
                   &amp;#40;dolist &amp;#40;j &amp;#40;vertex-out &amp;#40;aref graph i&amp;#41;&amp;#41;&amp;#41;
                     &amp;#40;setf &amp;#40;vertex-in &amp;#40;aref graph j&amp;#41;&amp;#41;
                           &amp;#40;delete i &amp;#40;vertex-in &amp;#40;aref graph j&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
                   &amp;#40;setf &amp;#40;aref graph i&amp;#41; nil&amp;#41;
                   &amp;#40;topologic-sort graph&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

;; add five edges
&amp;#40;add-vertex 0 '&amp;#40;&amp;#41; '&amp;#40;1 2 3&amp;#41;&amp;#41;
&amp;#40;add-vertex 1 '&amp;#40;0 2&amp;#41; '&amp;#40;&amp;#41;&amp;#41;
&amp;#40;add-vertex 2 '&amp;#40;0&amp;#41; '&amp;#40;1 4&amp;#41;&amp;#41;
&amp;#40;add-vertex 3 '&amp;#40;0 5&amp;#41; '&amp;#40;4&amp;#41;&amp;#41;
&amp;#40;add-vertex 4 '&amp;#40;2 3 5&amp;#41; '&amp;#40;&amp;#41;&amp;#41;
&amp;#40;add-vertex 5 '&amp;#40;&amp;#41; '&amp;#40;3 4&amp;#41;&amp;#41;
&amp;#40;topologic-sort&amp;#41;
;; output
;; 0
;; 2
;; 1
;; 5
;; 3
;; 4&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a id=&quot;org058f8f1&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;拓扑排序算法二&quot;&gt;拓扑排序算法二&lt;/h2&gt;&lt;p&gt;利用深度优先搜索的思想：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;构建一个栈。&lt;/li&gt;&lt;li&gt;从任意顶点v开始：&lt;/li&gt;&lt;li&gt;对v的所有临界顶点递归调用拓扑排序。&lt;/li&gt;&lt;li&gt;将v压入栈中。&lt;/li&gt;&lt;li&gt;还有未入栈顶点？跳到第2步。&lt;/li&gt;&lt;li&gt;弹出栈中所有顶点。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;common lisp实现如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defstruct vertex
  index
  adjacent&amp;#41;

&amp;#40;defparameter &amp;#42;graph&amp;#42; nil&amp;#41;
&amp;#40;defparameter &amp;#42;stack&amp;#42; nil&amp;#41;
&amp;#40;defparameter &amp;#42;visited&amp;#42; nil&amp;#41;

&amp;#40;defun add-vertex &amp;#40;index adjacent&amp;#41;
  &amp;#40;setf &amp;#40;aref &amp;#42;graph&amp;#42; index&amp;#41;
        &amp;#40;make-vertex :index index
                     :adjacent adjacent&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defun make-graph &amp;#40;n&amp;#41;
  &amp;#40;setf &amp;#42;graph&amp;#42; &amp;#40;make-array n :element-type 'vertex&amp;#41;&amp;#41;
  &amp;#40;setf &amp;#42;visited&amp;#42; &amp;#40;make-array n :initial-element nil&amp;#41;&amp;#41;
  &amp;#40;setf &amp;#42;stack&amp;#42; nil&amp;#41;&amp;#41;

&amp;#40;defun topologic-sort-util &amp;#40;n &amp;amp;optional &amp;#40;graph &amp;#42;graph&amp;#42;&amp;#41;&amp;#41;
  &amp;#40;setf &amp;#40;aref &amp;#42;visited&amp;#42; n&amp;#41; t&amp;#41;
  &amp;#40;dolist &amp;#40;i &amp;#40;vertex-adjacent &amp;#40;aref graph n&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;unless &amp;#40;aref &amp;#42;visited&amp;#42; i&amp;#41;
      &amp;#40;topologic-sort-util i graph&amp;#41;&amp;#41;&amp;#41;
  &amp;#40;push n &amp;#42;stack&amp;#42;&amp;#41;&amp;#41;

&amp;#40;defun topologic-sort &amp;#40;&amp;amp;optional &amp;#40;graph &amp;#42;graph&amp;#42;&amp;#41;&amp;#41;
  &amp;#40;dotimes &amp;#40;i &amp;#40;length &amp;#42;visited&amp;#42;&amp;#41;&amp;#41;
    &amp;#40;unless &amp;#40;aref &amp;#42;visited&amp;#42; i&amp;#41;
      &amp;#40;topologic-sort-util i graph&amp;#41;&amp;#41;&amp;#41;
  &amp;#40;dolist &amp;#40;e &amp;#42;stack&amp;#42;&amp;#41;
    &amp;#40;format t &amp;quot;&amp;#126;A&amp;#126;%&amp;quot; e&amp;#41;&amp;#41;&amp;#41;

&amp;#40;progn &amp;#40;make-graph 6&amp;#41;
       &amp;#40;add-vertex 0 '&amp;#40;1 2 3&amp;#41;&amp;#41;
       &amp;#40;add-vertex 1 '&amp;#40;&amp;#41;&amp;#41;
       &amp;#40;add-vertex 2 '&amp;#40;1 4&amp;#41;&amp;#41;
       &amp;#40;add-vertex 3 '&amp;#40;4&amp;#41;&amp;#41;
       &amp;#40;add-vertex 4 '&amp;#40;&amp;#41;&amp;#41;
       &amp;#40;add-vertex 5 '&amp;#40;3 4&amp;#41;&amp;#41;&amp;#41;&lt;/code&gt;&lt;/pre&gt;
</description>
<pubDate>
Sat, 02 Dec 2017 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/blog/posts-output/2017-12-1-when_to_use_define_compiler_macro/
</guid>
<link>
http://blogawesome.com/blog/posts-output/2017-12-1-when_to_use_define_compiler_macro/
</link>
<title>
何时使用compiler macro
</title>
<description>
&lt;p&gt;define-compiler-macro用于定义编译器宏。&lt;/p&gt;&lt;p&gt;按照CLHS的说法：unlike an ordinary macro, a compiler macro can decline to provide an expansion merely by returning a form that is the same as the original(which can be obtaned by using &amp;whole)。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defun square&amp;#40;x&amp;#41; &amp;#40;expt x 2&amp;#41;&amp;#41;
&amp;#40;define-compiler-macro square &amp;#40;&amp;amp;whole form arg&amp;#41;
    &amp;#40;if &amp;#40;atom arg&amp;#41;
        `&amp;#40;expt ,arg 2&amp;#41;
        &amp;#40;case &amp;#40;car arg&amp;#41;
            &amp;#40;square &amp;#40;if &amp;#40;= &amp;#40;length arg&amp;#41; 2&amp;#41;
                        `&amp;#40;expt ,&amp;#40;nth 1 arg&amp;#41; 4&amp;#41;
                        form&amp;#41;&amp;#41;
            &amp;#40;expt &amp;#40;if &amp;#40;= &amp;#40;length arg&amp;#41; 3&amp;#41;
                      &amp;#40;if &amp;#40;numberp &amp;#40;nth 2 arg&amp;#41;&amp;#41;
                          `&amp;#40;expt ,&amp;#40;nth 1 arg&amp;#41; ,&amp;#40;&amp;#42; 2 &amp;#40;nth 2 arg&amp;#41;&amp;#41;&amp;#41;
                          `&amp;#40;expt ,&amp;#40;nth 1 arg&amp;#41; &amp;#40;&amp;#42; 2 ,&amp;#40;nth 2 arg&amp;#41;&amp;#41;&amp;#41;&amp;#41;
                      form&amp;#41;&amp;#41;
            &amp;#40;otherwise `&amp;#40;expt ,arg 2&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;funcall &amp;#40;compiler-macro-function 'square&amp;#41; '&amp;#40;square x&amp;#41; nil&amp;#41; ;;  =&amp;gt; &amp;#40;EXPT X 2&amp;#41;
&amp;#40;funcall &amp;#40;compiler-macro-function 'square&amp;#41; '&amp;#40;square &amp;#40;square x&amp;#41;&amp;#41; nil&amp;#41; ;; =&amp;gt; &amp;#40;EXPT X 4&amp;#41;
&amp;#40;funcall &amp;#40;compiler-macro-function 'square&amp;#41; '&amp;#40;funcall #'square x&amp;#41; nil&amp;#41;  ;; =&amp;gt; &amp;#40;EXPT X 2&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译器宏通常用于极度优化特定的代码片段。如果一个算法在参数为常量是可以非常快，那么编译器宏在此种情形下会返回一个极快的版本；如果参数不为常量，编译器宏返回通常的算法实现。 编译器宏与普通宏的区别在于编译器宏可以遮蔽(shadow)一个同名函数，这使你可以在没有可以优化的可能时调用同名的函数实现。 通常情况下，你不需要使用编译器宏，除非你想要极度优化你的代码, 编译器宏牺牲编译时间换取更快的运行速度。&lt;/p&gt;&lt;p&gt;例子：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;define-compiler-macro fib &amp;#40;n &amp;amp;whole w&amp;#41;
    &amp;#40;if &amp;#40;intergerp n&amp;#41;
        ;; one case
        w&amp;#41;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译时，编译器无法知道(fib x) 中x的类型，因此，不会被优化；但是在(fib 10)中，编译器知道10的类型满足integerp，因此(fib 10)的值会被计算插入到原来的代码处。&lt;/p&gt;
</description>
<pubDate>
Fri, 01 Dec 2017 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/blog/posts-output/2017-11-29-guide_to_scaling_11m_users_on_amazon/
</guid>
<link>
http://blogawesome.com/blog/posts-output/2017-11-29-guide_to_scaling_11m_users_on_amazon/
</link>
<title>
新手引导：利用AWS伸缩到千万级用户
</title>
<description>
&lt;p&gt;&lt;div id=&quot;table-of-contents&quot;&gt; &lt;h2&gt;Table of Contents&lt;/h2&gt; &lt;div id=&quot;text-table-of-contents&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#org85a7ed2&quot;&gt;1. 新手引导：利用AWS伸缩到千万级用户&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#org62393be&quot;&gt;1.1. 基础&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#orgcac6e52&quot;&gt;1.2. 单用户&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#org6dc4f36&quot;&gt;1.3. 垂直伸缩&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#org2120e3c&quot;&gt;1.4. 用户量大于10&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#org8ec8903&quot;&gt;1.5. 用户量大于100&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#orgd304dc7&quot;&gt;1.6. 用户量大于1000&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#org015df2f&quot;&gt;1.7. 用户量一万到十万&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#orga52b1fe&quot;&gt;1.8. 自动伸缩&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#org7ba5bea&quot;&gt;1.9. 用户量大于50万&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#org1c92550&quot;&gt;1.10. 自动化&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#org544f2c1&quot;&gt;1.11. 解耦架构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#org0a31f1d&quot;&gt;1.12. 不要重复发明轮子&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#org727f571&quot;&gt;1.13. 用户量大于一百万&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#orgcf3fe1a&quot;&gt;1.14. 用户量大于一千万&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#org4af6b98&quot;&gt;1.15. 用户量大于1000万&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#org49c6bf3&quot;&gt;1.16. 总结&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/p&gt;&lt;p&gt;&lt;a id=&quot;org85a7ed2&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h1 id=&quot;新手引导：利用aws伸缩到千万级用户&quot;&gt;新手引导：利用AWS伸缩到千万级用户&lt;/h1&gt;&lt;p&gt;本文翻译自：&lt;a href='http://highscalability.com/blog/2016/1/11/a-beginners-guide-to-scaling-to-11-million-users-on-amazons.html'&gt;HighScalability&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;如何将系统从单用户伸缩到千万级的用户量？Joel Williams,亚马逊的Web服务方案架构师，就此话题做了一个不错的演讲:&lt;a href='https://www.youtube.com/watch?v=vg5onp8TU6Q&amp;list=PLhr1KZpdzukdRxs_pGJm-qSy5LayL6W_Y'&gt;AWS re:Invent 2015 Scaling Up to Your First 10 Million Users&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;如果你是高级AWS用户，这份演讲可能对你没什么用处。但对于新手来说，这却是一个很好的起点。&lt;/p&gt;&lt;p&gt;这份演讲出自亚马逊，所以演讲中亚马逊的服务是解决所有问题的核心。&lt;/p&gt;&lt;p&gt;下面是一些有趣的总结：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;从SQL开始，只有在必要时才迁移到NOSQL。&lt;/li&gt;&lt;li&gt;将系统中的模块分离，使它们可以独立的伸缩并实现差错隔离。&lt;/li&gt;&lt;li&gt;将精力投入到你的核心商业业务，不要重新发明轮子。&lt;/li&gt;&lt;li&gt;伸缩性和冗余性不是两个分离的概念，你通常能够同时实现二者。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a id=&quot;org62393be&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;基础&quot;&gt;基础&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;AWS在全球有12个区。    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 一个区是一个具体的物理位置，其中包含了多个可用域&amp;#40;AZ, Available Zone&amp;#41;。

&amp;#40;2&amp;#41; 一个可用域通常由一个数据中心或者多个数据中心组成。

&amp;#40;3&amp;#41; 各个可用域之间相互独立，具有独立的电力和网络。

&amp;#40;4&amp;#41; 可用域之间用低延迟网络连接，在地理位置上相距5至15英里。由于网络延迟极低，在应用程序看来，所有的可用域就像是一个整体。

&amp;#40;5&amp;#41; 每个区至少有两个可用域。&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;AWS在全球有53个边缘区(Edge Location)    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 边缘区用于CloudFront,CDN,Route53和Amazon DNS服务

&amp;#40;2&amp;#41; 边缘区使用户可以低延迟的访问数据,无论在什么地理位置.&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;构建块    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; AWS提供了众多的构建块服务，这些服务使用可用域作为支撑，具备高可用和容错性。

&amp;#40;2&amp;#41; 你可以付费使用这些服务构建应用，而不是自己构建这些高可用的服务。

&amp;#40;3&amp;#41; 可用域包含的服务有：CloudFront, Route53, S3, DynamoDb, Elastic Load Balancing, EFS, lambda, SQS, SNS, SES, SWF。

&amp;#40;4&amp;#41; 使用单一的可用域也可以构建出高可用的应用程序架构。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a id=&quot;orgcac6e52&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;单用户&quot;&gt;单用户&lt;/h2&gt;&lt;p&gt;此种情形下，你是唯一的用户，你需要一个可以运行的网站。&lt;/p&gt;&lt;p&gt;你的架构可能是这样的：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;应用运行在单一的服务器中。&lt;/li&gt;&lt;li&gt;单一服务器运行整个程序栈：网络层，数据库，管理层..&lt;/li&gt;&lt;li&gt;使用Amazon Route 53做DNS。&lt;/li&gt;&lt;li&gt;为应用绑定一个&lt;a href='http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html'&gt;Elastic IP&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;应用在一段时间可以工作地很好。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a id=&quot;org6dc4f36&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;垂直伸缩&quot;&gt;垂直伸缩&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;你需要一个性能更好的主机。最简单的方案是选择&lt;a href='http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/c4-instances.html'&gt;c4.8xlarge&lt;/a&gt; 或者&lt;a href='https://aws.amazon.com/ec2/instance-types/'&gt;om3.2xlarge&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;垂直伸缩的问题在于：没有差错转移，没有冗余。如果应用出现一个问题，整个服务可能不可用。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a id=&quot;org2120e3c&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;用户量大于10&quot;&gt;用户量大于10&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;单服务器模式切换到多服务器模式。    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 一个主机用于web层。

&amp;#40;2&amp;#41; 一个主机用于数据库，或者运行任意多个数据库，这些数据库都由你管理。

&amp;#40;3&amp;#41; 将web主机与数据库主机分离开来可以让它们独立的伸缩。&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;除了运行自己的数据库，你也可以使用数据库服务。    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 你是数据库管理员吗？你想要自己关心数据备份，高可用，打包，操作系统等问题吗？

&amp;#40;2&amp;#41; 使用数据库服务的优势在于：你可以一键点击就生成分布在多个可用域的数据服务，而且是高可用，高可靠的。&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;AWS提供了多种数据库服务：    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; Amazon RDS关系数据库服务。

&amp;#40;2&amp;#41; Amazon DynamoDB Nosql数据库服务。

&amp;#40;3&amp;#41; Amazon Redshift 千兆兆级别数据仓库服务。&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;Amazon Aurora    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 自动伸缩到64tb。不用再关心数据的存储。

&amp;#40;2&amp;#41; 有多达15个读集。

&amp;#40;3&amp;#41; 数据增量备份。

&amp;#40;4&amp;#41; 跨越３个可用域的六路数据备份，这可以帮助解决数据访问失败的问题。

&amp;#40;5&amp;#41; 兼容mysql。&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;从SQL起步，而不是NOSQL    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 建议从SQL开始构建数据存储

&amp;#40;2&amp;#41; SQL技术比较成熟

&amp;#40;3&amp;#41; SQL有大量的现存代码，社区，支持组，书籍，以及工具。

&amp;#40;4&amp;#41; SQL足以满足你前1000万用户的需求。

&amp;#40;5&amp;#41; SQL清楚的数据模式便于构建可伸缩的数据服务。&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;什么时候可以从NOSQL起步?    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 你首年即需存储５TB以上的数据或者你的应用有极大的数据紧密性任务。

&amp;#40;2&amp;#41; 你的应用有极低延迟的需求。

&amp;#40;3&amp;#41; 你真的需要高吞吐量。你需要优化读写的性能。

&amp;#40;4&amp;#41; 你的应用中没有关系型数据。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a id=&quot;org8ec8903&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;用户量大于100&quot;&gt;用户量大于100&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;使用单独的主机，用于网络层。&lt;/li&gt;&lt;li&gt;将数据存储到Amazon RDS，由它管理一切。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a id=&quot;orgd304dc7&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;用户量大于1000&quot;&gt;用户量大于1000&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;在另一个可用域中开启另一个网络层实例，这样可以提高服务可用性，同时，由于可用域之间网络延迟极低，两个网络层实例就好像一个实例一样。&lt;/li&gt;&lt;li&gt;在另一个可用域中开启一个从数据库，在主数据库故障时，应用程序会自动地向从数据库发送请求。&lt;/li&gt;&lt;li&gt;在配置中加入弹性负载均衡(Elastic Load Balancer, ELB), 用于在你的两个网络实例之间进行负载均衡。    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; ELB是高可用可管理的负载均衡器。在所有的可用域中均可使用，他是你应用程序的唯一DNS端口。

&amp;#40;2&amp;#41; ELB具有健康检测功能，这可以保证请求不会流入故障的主机。

&amp;#40;3&amp;#41; ELB帮助你进行架构伸缩，让你无需操心太多。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a id=&quot;org015df2f&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;用户量一万到十万&quot;&gt;用户量一万到十万&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;水平伸缩，在ELB之后可以有1000或更多个网络实例。&lt;/li&gt;&lt;li&gt;添加更多的只读数据集。&lt;/li&gt;&lt;li&gt;考虑到网络层的性能，将网络层的一些流量分离到其他模块，将静态内容移动到Amazon S3和Amazon CloudFront。CloudFront将你的数据存储到边缘区(Edge Location)。&lt;/li&gt;&lt;li&gt;Amazon S3是一个对象存储。&lt;/li&gt;&lt;li&gt;Amazon CloudFront是应用的缓存。&lt;/li&gt;&lt;li&gt;你也可以将回话状态存储到ElasticCache或者DynamoDB，从而减轻网络层的负载。&lt;/li&gt;&lt;li&gt;将数据库的数据缓存到ElastiCache。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a id=&quot;orga52b1fe&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;自动伸缩&quot;&gt;自动伸缩&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;如果你提供足够的资源，能够满足应用高峰时的流量需求，在闲时，你却在浪费资源。&lt;/li&gt;&lt;li&gt;你可以定义最大和最小资源池。&lt;/li&gt;&lt;li&gt;CloudWatch是一个嵌入到所有应用的管理服务，提供伸缩性管理。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a id=&quot;org7ba5bea&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;用户量大于50万&quot;&gt;用户量大于50万&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;前一节中, 自动伸缩组加入到网络层配置中。自动伸缩组包括两个可用域，可以伸缩到３个或者更多可用域。&lt;/li&gt;&lt;li&gt;在每个可用域中有3个网络实例，其实可以增加到数千个实例。你可以配置最少需要10个实例，最多伸缩到1000个实例。&lt;/li&gt;&lt;li&gt;ElastiCache用于缓存热数据，减轻数据库负载。&lt;/li&gt;&lt;li&gt;DynamoDB用于管理会话数据。&lt;/li&gt;&lt;li&gt;为应用增加监控，度量，日志功能。&lt;/li&gt;&lt;li&gt;了解用户的体验，是否延迟过高或者遇到什么错误。&lt;/li&gt;&lt;li&gt;通过配置尽量利用系统性能，自动伸缩是很好的解决方案。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a id=&quot;org1c92550&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;自动化&quot;&gt;自动化&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;架构更加复杂，它能伸缩到1000个实例，具有只读数据集，可以水平伸缩。现在我们需要一些自动化管理工具来管理所有的实例。&lt;/li&gt;&lt;li&gt;AWS Elastic Beanstalk，自动管理你的应用设施。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a id=&quot;org544f2c1&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;解耦架构&quot;&gt;解耦架构&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;使用SOA/microservices。将应用组件分离出来，独立成为单独的服务，就好像你分离网络层和数据库一样。&lt;/li&gt;&lt;li&gt;每个服务都可以独立的伸缩，这带给你更多的灵活性和高可用性。&lt;/li&gt;&lt;li&gt;SOA是架构的核心组件。&lt;/li&gt;&lt;li&gt;低耦合使你更加灵活：    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 各组件独立伸缩，差错隔离。

&amp;#40;2&amp;#41; 如果一个工作节点故障，只需启动一个新的节点，这提高了错误处理能力。

&amp;#40;3&amp;#41; 将各个服务设计到独立的黑盒中。

&amp;#40;4&amp;#41; 在服务内部提供伸缩性和冗余性。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a id=&quot;org0a31f1d&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;不要重复发明轮子&quot;&gt;不要重复发明轮子&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;关注你的业务逻辑。&lt;/li&gt;&lt;li&gt;Amazon提供了很多高容错的服务。&lt;/li&gt;&lt;li&gt;SQS：队列服务。&lt;/li&gt;&lt;li&gt;AWS Lambda: 让你无需配置和管理服务器。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a id=&quot;org727f571&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;用户量大于一百万&quot;&gt;用户量大于一百万&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;用户量达到一百万需要前面提到的所有服务：    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 多个可用域

&amp;#40;2&amp;#41; Elastic Load Balanceing&amp;#40;ELB&amp;#41;。

&amp;#40;3&amp;#41; Service Oriented Architecture。

&amp;#40;4&amp;#41; 添加缓存。

&amp;#40;5&amp;#41; 将状态从网络层移除。&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;使用Amazon SES发送邮件。&lt;/li&gt;&lt;li&gt;使用CloudWatch进行监控。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a id=&quot;orgcf3fe1a&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;用户量大于一千万&quot;&gt;用户量大于一千万&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;随着用户量增大，数据层成了问题所在。写数据库负载过高，成为瓶颈。&lt;/li&gt;&lt;li&gt;如何解决？    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 联合

&amp;#40;2&amp;#41; 分片

&amp;#40;3&amp;#41; 将部分功能转移到Nosql&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;联合，基于功能将数据分配到多个数据库。    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 例如：论坛数据库，用户数据库，产品数据库等等。

&amp;#40;2&amp;#41; 各个数据库可以独立伸缩。

&amp;#40;3&amp;#41; 缺点：不能跨数据库查询，这引出了下一种策略：分片。&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;分片：将一个数据集切分到多个主机。    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 应用层变复杂，可扩展性没有限制。

&amp;#40;2&amp;#41; 比如：将1/3的用户存入shard1，1/3存入shard2，剩下的存入shard3。&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;将部分功能转移到NoSql&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a id=&quot;org4af6b98&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;用户量大于1000万&quot;&gt;用户量大于1000万&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;伸缩性是一个迭代的过程，随着用户量的增多，你总是可以找到更多的解决方案。&lt;/li&gt;&lt;li&gt;调优应用程序。&lt;/li&gt;&lt;li&gt;更多的SOA。&lt;/li&gt;&lt;li&gt;由多个可用域升级到多个可用区。&lt;/li&gt;&lt;li&gt;开始构建定制的解决方案，专用于解决你遇到的特定问题。&lt;/li&gt;&lt;li&gt;深入分析整个应用栈。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a id=&quot;org49c6bf3&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;使用多可用域提高可用性。&lt;/li&gt;&lt;li&gt;使用自动伸缩服务。&lt;/li&gt;&lt;li&gt;在应用的各级构建冗余，可伸缩性和冗余性可以同时实现。&lt;/li&gt;&lt;li&gt;有关系性数据库开始构建应用。&lt;/li&gt;&lt;li&gt;缓存数据。&lt;/li&gt;&lt;li&gt;使用自动化管理工具。&lt;/li&gt;&lt;li&gt;保证有较好的测量，监控，日志工具。&lt;/li&gt;&lt;li&gt;SOA。&lt;/li&gt;&lt;li&gt;将部分数据迁移到NoSql。&lt;/li&gt;&lt;/ol&gt;
</description>
<pubDate>
Wed, 29 Nov 2017 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/blog/posts-output/2017-11-25-twenty-bottlenecks/
</guid>
<link>
http://blogawesome.com/blog/posts-output/2017-11-25-twenty-bottlenecks/
</link>
<title>
性能瓶颈列表
</title>
<description>
&lt;p&gt;该文翻译自&lt;a href='http://highscalability.com'&gt;HighScalability&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;在Zen And The Art of Scaling - A Koan And Epigram Approach一书中，Russell Sullian 提出了一个有趣的猜想：只有20种典型的性能瓶颈。这听起来颇具疑点， 就好像只有20种基本的故事情节这种说法一样。这种观点也许是对的，这完全取决于你如何划分事物。现实中，性能瓶颈总是以各种方式出现，给我们带来极大困扰。&lt;/p&gt;&lt;p&gt;一天Aurelien Broszniowski给我发了一封邮件，里面是他认为的性能瓶颈的列表。我们把这份列表也寄给了Russell，他回寄给我们一份他所整理的性能瓶颈列表。下面是我们整理的最终列表。&lt;/p&gt;&lt;p&gt;Russell非常珍视这份列表，他说他希望能在更年轻的时候就拥有这份列表。其实随着你经验的增加，你会处理更多不同类型的项目，从中学到更多的经验，并将它们添加到这份列表中。当你在列表 中增加自己的经验总结时，你正在品味多年来所累积的经验，而不是仅仅记得性能瓶颈带给你的那些沮丧。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;数据库    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 工作空间超出了可用内存。

&amp;#40;2&amp;#41; Long &amp;amp; Short running queries

&amp;#40;3&amp;#41; 写冲突

&amp;#40;4&amp;#41; Large joins taking up memory&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;虚拟存储    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; Sharing a HDD, disk seek death

&amp;#40;2&amp;#41; 基于云的网络IO不稳定&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;编程    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 多线程：死锁，不如事件轻量，难以调试，非线性扩展..

&amp;#40;2&amp;#41; 事件驱动编程：复杂的回调，在函数调用中难以存储状态..

&amp;#40;3&amp;#41; 没有性能检测，没有执行流程追踪，没有日志..

&amp;#40;4&amp;#41; 非模块化，难以伸缩。SPOF&amp;#40;single point of failure&amp;#41;，一个失败导致整个系统不可用。非水平性伸缩。

&amp;#40;5&amp;#41; 状态化的应用

&amp;#40;6&amp;#41; 糟糕的设计：随着用户的增多，应用不能运行，需要重新设计并编写。

&amp;#40;7&amp;#41; 算法复杂

&amp;#40;8&amp;#41; 服务依赖: 依赖于其他会使程序阻塞的服务，比如DNS查询。&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;磁盘    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 本地磁盘访问

&amp;#40;2&amp;#41; 随机磁盘访问，磁盘寻址

&amp;#40;3&amp;#41; 磁盘碎片化

&amp;#40;4&amp;#41; 当数据量超过了SSD容量，性能下降&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;系统    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; fsync冲刷, linux文件缓存已满

&amp;#40;2&amp;#41; TCP缓冲区太小

&amp;#40;3&amp;#41; 文件描述符限制

&amp;#40;4&amp;#41; 功率分配&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;缓存    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 缺乏缓存，频繁访问数据库

&amp;#40;2&amp;#41; HTTP: 没有压缩数据

&amp;#40;3&amp;#41; 没有充分利用浏览器的缓存

&amp;#40;4&amp;#41; 利用字节码缓存

&amp;#40;5&amp;#41; 将总要的热数据保存在L1/L2缓存中&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;处理器    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; CPU过载

&amp;#40;2&amp;#41; 过多的上下文切换：单核上线程太多，太多的系统调用

&amp;#40;3&amp;#41; 过多的IO等待，所有的cpu以相同的速率等待IO

&amp;#40;4&amp;#41; CPU高速缓存，在充分利用缓存和保持数据一致之间找到平衡点&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;网络    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 网卡过载，快速中断饱和，软中断占用大量CPU时间

&amp;#40;2&amp;#41; DNS查询

&amp;#40;3&amp;#41; 网络包丢失

&amp;#40;4&amp;#41; 路由失败

&amp;#40;5&amp;#41; 网络磁盘访问

&amp;#40;6&amp;#41; 共享存储区域网络

&amp;#40;7&amp;#41; 服务器没有响应&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;开发过程    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 测试时间

&amp;#40;2&amp;#41; 开发时间

&amp;#40;3&amp;#41; 团队大小

&amp;#40;4&amp;#41; 预算&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&lt;li&gt;内存    &lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;1&amp;#41; 内存耗尽, 导致进程换入SWAP区或被停止

&amp;#40;2&amp;#41; 内存耗尽，导致磁盘颠簸

&amp;#40;3&amp;#41; 内存库负载过大

&amp;#40;4&amp;#41; 内存碎片过多&lt;/code&gt;&lt;/pre&gt;
</description>
<pubDate>
Sat, 25 Nov 2017 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/blog/posts-output/2016-01-07-docs/
</guid>
<link>
http://blogawesome.com/blog/posts-output/2016-01-07-docs/
</link>
<title>
Quick Start Guide
</title>
<description>
&lt;p&gt;This intro only documents a subset of Cryogen's features. For additional documentation please see the &lt;a href='http://cryogenweb.org'&gt;cryogen site&lt;/a&gt;.&lt;/p&gt;&lt;h2 id=&quot;features&quot;&gt;Features&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Blog posts and pages with Markdown (default) or AsciiDoc&lt;/li&gt;&lt;li&gt;Tags&lt;/li&gt;&lt;li&gt;Table of contents generation&lt;/li&gt;&lt;li&gt;Plain HTML page templates&lt;/li&gt;&lt;li&gt;Code syntax highlighting&lt;/li&gt;&lt;li&gt;Disqus support&lt;/li&gt;&lt;li&gt;Sitemap generation&lt;/li&gt;&lt;li&gt;RSS feed generation&lt;/li&gt;&lt;li&gt;Sass/SCSS compilation&lt;/li&gt;&lt;li&gt;Klipse Integration&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;prerequisites&quot;&gt;Prerequisites&lt;/h2&gt;&lt;p&gt;You will need &lt;a href='https://github.com/technomancy/leiningen'&gt;Leiningen&lt;/a&gt; 2.5.0 or above installed.&lt;/p&gt;&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;&lt;h3 id=&quot;creating&amp;#95;a&amp;#95;new&amp;#95;site&quot;&gt;Creating a New Site&lt;/h3&gt;&lt;p&gt;A new site can be created using the Cryogen template as follows:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;lein new cryogen my-blog
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;running&amp;#95;the&amp;#95;server&quot;&gt;Running the Server&lt;/h3&gt;&lt;p&gt;The web server can be started from the &lt;code&gt;my-blog&lt;/code&gt; directory using the &lt;code&gt;lein-ring&lt;/code&gt; plugin:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;lein ring server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The server will watch for changes in the &lt;code&gt;resources/templates&lt;/code&gt; folder and recompile the content automatically.&lt;/p&gt;&lt;h3 id=&quot;site&amp;#95;configuration&quot;&gt;Site Configuration&lt;/h3&gt;&lt;p&gt;The site configuration file is found at &lt;code&gt;templates/config.edn&lt;/code&gt;, this file looks as follows:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:site-title           &amp;quot;My Awesome Blog&amp;quot;
 :author               &amp;quot;Bob Bobbert&amp;quot;
 :description          &amp;quot;This blog is awesome&amp;quot;
 :site-url             &amp;quot;http://blogawesome.com/&amp;quot;
 :post-root            &amp;quot;posts&amp;quot;
 :page-root            &amp;quot;pages&amp;quot;
 :post-root-uri        &amp;quot;posts-output&amp;quot;
 :page-root-uri        &amp;quot;pages-output&amp;quot;
 :tag-root-uri         &amp;quot;tags-output&amp;quot;
 :author-root-uri      &amp;quot;authors-output&amp;quot;
 :blog-prefix          &amp;quot;/blog&amp;quot;
 :rss-name             &amp;quot;feed.xml&amp;quot;
 :rss-filters          &amp;#91;&amp;quot;cryogen&amp;quot;&amp;#93;
 :recent-posts         3
 :post-date-format     &amp;quot;yyyy-MM-dd&amp;quot;
 :archive-group-format &amp;quot;yyyy MMMM&amp;quot;
 :sass-src             &amp;#91;&amp;#93;
 :sass-path            &amp;quot;sass&amp;quot;
 :compass-path         &amp;quot;compass&amp;quot;
 :theme                &amp;quot;blue&amp;quot;
 :resources            &amp;#91;&amp;quot;img&amp;quot;&amp;#93;
 :keep-files           &amp;#91;&amp;quot;.git&amp;quot;&amp;#93;
 :disqus?              false
 :disqus-shortname     &amp;quot;&amp;quot;
 :ignored-files        &amp;#91;#&amp;quot;\.#.&amp;#42;&amp;quot; #&amp;quot;.&amp;#42;\.swp$&amp;quot;&amp;#93;
 :posts-per-page       5
 :blocks-per-preview   2
 :previews?            false
 :clean-urls?          true
 :hide-future-posts?   true
 :klipse               {}
 :debug?               false}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For information about each key please see the &lt;a href='http://cryogenweb.org/docs/configuration.html'&gt;&quot;Configuration&quot;&lt;/a&gt; portion of the Cryogen documentation site.&lt;/p&gt;&lt;h3 id=&quot;switching&amp;#95;between&amp;#95;markdown&amp;#95;and&amp;#95;asciidoc&quot;&gt;Switching between Markdown and AsciiDoc&lt;/h3&gt;&lt;p&gt;Cryogen comes with Markdown support as default. If you want to use AsciiDoc instead, open the &lt;code&gt;project.clj&lt;/code&gt; in your created blog (e.g. &lt;code&gt;my-blog&lt;/code&gt;), and change the line in &lt;code&gt;:dependencies&lt;/code&gt; that says &lt;code&gt;cryogen-markdown&lt;/code&gt; to &lt;code&gt;cryogen-asciidoc&lt;/code&gt;. Instead of looking for files ending in &lt;code&gt;.md&lt;/code&gt; in the &lt;code&gt;resources/templates/md&lt;/code&gt; directory, the compiler will now look for files ending in &lt;code&gt;.asc&lt;/code&gt; in the &lt;code&gt;resources/templates/asc&lt;/code&gt; directory.&lt;/p&gt;&lt;h3 id=&quot;selecting&amp;#95;a&amp;#95;theme&quot;&gt;Selecting a Theme&lt;/h3&gt;&lt;p&gt;The Cryogen template comes with two themes in the &lt;code&gt;resources/templates/themes&lt;/code&gt; folder. To change your blog's theme, change the value of the &lt;code&gt;:theme&lt;/code&gt; key in &lt;code&gt;config.edn&lt;/code&gt;.&lt;/p&gt;&lt;h3 id=&quot;customizing&amp;#95;layouts&quot;&gt;Customizing Layouts&lt;/h3&gt;&lt;p&gt;Cryogen uses &lt;a href='https://github.com/yogthos/Selmer'&gt;Selmer&lt;/a&gt; templating engine for layouts. Please refer to its documentation to see the supported tags and filters for the layouts.&lt;/p&gt;&lt;p&gt;The layouts are contained in the &lt;code&gt;resources/templates/themes/{theme}/html&lt;/code&gt; folder of the project. By default, the &lt;code&gt;base.html&lt;/code&gt; layout is used to provide the general layout for the site. This is where you would add static resources such as CSS and JavaScript assets as well as define headers and footers for your site.&lt;/p&gt;&lt;p&gt;Each page layout should have a name that matches the &lt;code&gt;:layout&lt;/code&gt; key in the page metadata and end with &lt;code&gt;.html&lt;/code&gt;. Page layouts extend the base layout and should only contain the content relevant to the page inside the &lt;code&gt;content&lt;/code&gt; block. For example, the &lt;code&gt;tag&lt;/code&gt; layout is located in &lt;code&gt;tag.html&lt;/code&gt; and looks as follows:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;{% extends &amp;quot;templates/html/layouts/base.html&amp;quot; %}
{% block content %}
&amp;lt;div id=&amp;quot;posts-by-tag&amp;quot;&amp;gt;
    &amp;lt;h2&amp;gt;Posts tagged {{name}}&amp;lt;/h2&amp;gt;
    &amp;lt;ul&amp;gt;
    {% for post in posts %}
        &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;{{post.uri}}&amp;quot;&amp;gt;{{post.title}}&amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
    {% endfor %}
    &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;code&amp;#95;syntax&amp;#95;highlighting&quot;&gt;Code Syntax Highlighting&lt;/h3&gt;&lt;p&gt;Cryogen uses &lt;a href='https://highlightjs.org/'&gt;Highlight.js&lt;/a&gt; for code syntax highlighting. You can add more languages by replacing &lt;code&gt;templates/js/highlight.pack.js&lt;/code&gt; with a customized package from &lt;a href='https://highlightjs.org/download/'&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The &lt;code&gt; initHighlightingOnLoad&lt;/code&gt; function is called in &lt;code&gt;{theme}/html/base.html&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;script&amp;gt;hljs.initHighlightingOnLoad&amp;#40;&amp;#41;;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;deploying&amp;#95;your&amp;#95;site&quot;&gt;Deploying Your Site&lt;/h2&gt;&lt;p&gt;The generated static content will be found under the &lt;code&gt;resources/public&lt;/code&gt; folder. Simply copy the content to a static folder for a server such as Nginx or Apache and your site is now ready for service.&lt;/p&gt;&lt;p&gt;A sample Nginx configuration that's placed in &lt;code&gt;/etc/nginx/sites-available/default&lt;/code&gt; can be seen below:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;server {
  listen 80 default&amp;#95;server;
  listen &amp;#91;::&amp;#93;:80 default&amp;#95;server ipv6only=on;
  server&amp;#95;name localhost &amp;lt;yoursite.com&amp;gt; &amp;lt;www.yoursite.com&amp;gt;;

  access&amp;#95;log  /var/log/blog&amp;#95;access.log;
  error&amp;#95;log   /var/log/blog&amp;#95;error.log;

  location / {
    alias       /var/blog/;
    error&amp;#95;page  404 = /404.html;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Simply set &lt;code&gt;yoursite.com&lt;/code&gt; to the domain of your site in the above configuration and ensure the static content is available at &lt;code&gt;/var/blog/&lt;/code&gt;. Finally, place your custom error page in the &lt;code&gt;/var/blog/404.html&lt;/code&gt; file.&lt;/p&gt;&lt;p&gt;More information on deployment can be found &lt;a href='http://cryogenweb.org/docs/deploying-to-github-pages.html'&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;h2 id=&quot;some&amp;#95;sites&amp;#95;made&amp;#95;with&amp;#95;cryogen&quot;&gt;Some Sites Made With Cryogen&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='http://carmenla.me/blog/archives'&gt;My personal blog&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://cryogenweb.org'&gt;Cryogen Documentation Site&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://yogthos.net/'&gt;Yogthos' blog&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://www.agynamix.de'&gt;AGYNAMIX Site &amp; Blog&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://www.chadstovern.com'&gt;Chad Stovern's blog&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://lambdax.io/blog/'&gt;LambdaX&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://www.szcz.org/'&gt;szcz&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://blog.isvit.info'&gt;ISvit blog&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://lambdafunk.com'&gt;Lambda Funk&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://ddft.wiki'&gt;DDFT.wiki&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
</description>
<pubDate>
Thu, 07 Jan 2016 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/blog/posts-output/2014-11-04-second-post/
</guid>
<link>
http://blogawesome.com/blog/posts-output/2014-11-04-second-post/
</link>
<title>
Yet Another Post
</title>
<description>
&lt;h3 id=&quot;this&amp;#95;post&amp;#95;so&amp;#95;fetch&quot;&gt;This Post So Fetch&lt;/h3&gt;&lt;p&gt;some more stuff happened&lt;/p&gt;
</description>
<pubDate>
Tue, 04 Nov 2014 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/blog/posts-output/2014-03-10-first-post/
</guid>
<link>
http://blogawesome.com/blog/posts-output/2014-03-10-first-post/
</link>
<title>
A Post
</title>
<description>
&lt;h3 id=&quot;this&amp;#95;post&amp;#95;not&amp;#95;fetch&amp;#95;enough&quot;&gt;This Post Not Fetch Enough&lt;/h3&gt;&lt;p&gt;some stuff happened&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; Stop trying to make fetch happen. &lt;/p&gt;&lt;footer&gt; Regina&lt;/footer&gt;&lt;/blockquote&gt;
</description>
<pubDate>
Mon, 10 Mar 2014 00:00:00 +0800
</pubDate>
</item>
</channel>
</rss>
