{
:title "性能瓶颈列表"
:layout :post
:tags ["architecture" "translate"]
}

该文翻译自[HighScalability](http://highscalability.com)。

在Zen And The Art of Scaling - A Koan And Epigram Approach一书中，Russell Sullian 提出了一个有趣的猜想：只有20种典型的性能瓶颈。这听起来颇具疑点，
就好像只有20种基本的故事情节这种说法一样。这种观点也许是对的，这完全取决于你如何划分事物。现实中，性能瓶颈总是以各种方式出现，给我们带来极大困扰。

一天Aurelien Broszniowski给我发了一封邮件，里面是他认为的性能瓶颈的列表。我们把这份列表也寄给了Russell，他回寄给我们一份他所整理的性能瓶颈列表。下面是我们整理的最终列表。

Russell非常珍视这份列表，他说他希望能在更年轻的时候就拥有这份列表。其实随着你经验的增加，你会处理更多不同类型的项目，从中学到更多的经验，并将它们添加到这份列表中。当你在列表
中增加自己的经验总结时，你正在品味多年来所累积的经验，而不是仅仅记得性能瓶颈带给你的那些沮丧。

1.  数据库
    
    (1) 工作空间超出了可用内存。
    
    (2) Long & Short running queries
    
    (3) 写冲突
    
    (4) Large joins taking up memory

2.  虚拟存储
    
    (1) Sharing a HDD, disk seek death
    
    (2) 基于云的网络IO不稳定

3.  编程
    
    (1) 多线程：死锁，不如事件轻量，难以调试，非线性扩展..
    
    (2) 事件驱动编程：复杂的回调，在函数调用中难以存储状态..
    
    (3) 没有性能检测，没有执行流程追踪，没有日志..
    
    (4) 非模块化，难以伸缩。SPOF(single point of failure)，一个失败导致整个系统不可用。非水平性伸缩。
    
    (5) 状态化的应用
    
    (6) 糟糕的设计：随着用户的增多，应用不能运行，需要重新设计并编写。
    
    (7) 算法复杂
    
    (8) 服务依赖: 依赖于其他会使程序阻塞的服务，比如DNS查询。

4.  磁盘
    
    (1) 本地磁盘访问
    
    (2) 随机磁盘访问，磁盘寻址
    
    (3) 磁盘碎片化
    
    (4) 当数据量超过了SSD容量，性能下降

5.  系统
    
    (1) fsync冲刷, linux文件缓存已满
    
    (2) TCP缓冲区太小
    
    (3) 文件描述符限制
    
    (4) 功率分配

6.  缓存
    
    (1) 缺乏缓存，频繁访问数据库
    
    (2) HTTP: 没有压缩数据
    
    (3) 没有充分利用浏览器的缓存
    
    (4) 利用字节码缓存
    
    (5) 将总要的热数据保存在L1/L2缓存中

7.  处理器
    
    (1) CPU过载
    
    (2) 过多的上下文切换：单核上线程太多，太多的系统调用
    
    (3) 过多的IO等待，所有的cpu以相同的速率等待IO
    
    (4) CPU高速缓存，在充分利用缓存和保持数据一致之间找到平衡点

1.  网络
    
    (1) 网卡过载，快速中断饱和，软中断占用大量CPU时间
    
    (2) DNS查询
    
    (3) 网络包丢失
    
    (4) 路由失败
    
    (5) 网络磁盘访问
    
    (6) 共享存储区域网络
    
    (7) 服务器没有响应

2.  开发过程
    
    (1) 测试时间
    
    (2) 开发时间
    
    (3) 团队大小
    
    (4) 预算

3.  内存
    
    (1) 内存耗尽, 导致进程换入SWAP区或被停止
    
    (2) 内存耗尽，导致磁盘颠簸
    
    (3) 内存库负载过大
    
    (4) 内存碎片过多

